<!DOCTYPE html>
<html lang='en' class=' is-copy-enabled is-u2f-enabled'>
   <head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=1020'>
  <title>Match Replay</title>
  <link rel=icon href='images/favicon.png' sizes='96x96' type='image/png'>
  
  <script src="js/pixi.min.js"></script>
<style>
	body {
		margin: 0;
		padding: 0;
		background-color: #000000;
	}
</style>
</head>
<body>
</body>
<script type='text/javascript'>
	var query = (function(a) {
		if (a == "") return {};
		var b = {};
		for (var i = 0; i < a.length; ++i) {
			var p=a[i].split('=', 2);
			if (p.length == 1)
				b[p[0]] = "";
			else
				b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
		}
		return b;
	})(window.location.search.substr(1).split('&'));

stageWidth = window.innerWidth; 
stageHeight = window.innerHeight;
console.log(stageWidth, stageHeight);

// You can use either `new PIXI.WebGLRenderer`, `new PIXI.CanvasRenderer`, or `PIXI.autoDetectRenderer`
// which will try to choose the best renderer for the environment you are in.
var renderer = new PIXI.WebGLRenderer(stageWidth, stageHeight);

// The renderer will create a canvas element for you that you can then insert into the DOM.
document.body.appendChild(renderer.view);

// You need to create a root container that will hold the scene you want to draw.
var stage = new PIXI.Container();

var game = {render:{}};

var MS_PER_ROUND = 200;

// load the texture we need
PIXI.loader.add('bunny', 'https://raw.githubusercontent.com/pixijs/pixi.js/master/test/textures/bunny.png').load(function (loader, resources) {
	// This creates a texture from a 'bunny.png' image.
	var bunny = new PIXI.Sprite(resources.bunny.texture);
	game.render.bunny = bunny;

	// Setup the position and scale of the bunny
	bunny.position.x = renderer.width-25;
	bunny.position.y = 300;

	bunny.anchor.x = 0.5;
	bunny.anchor.y = 0.5;

	// Add the bunny to the scene we are building.
	stage.addChild(bunny);

	// kick off the animation loop (defined below)
	renderer.render(stage);
});

var sprites = {
	'ZOMBIEDEN':'images/zombieden.png',
	'TTM':'images/ttm.png',
	'TURRET':'images/turret.png',
	'VIPER':'images/viper.png',
	'GUARD':'images/guard.png',
	'SOLDIER':'images/soldier.png',
	'SCOUT':'images/scout.png',
	'ARCHON':'images/archon.png',
	'RANGEDZOMBIE':'images/rangedzombie.png',
	'STANDARDZOMBIE':'images/standardzombie.png',
	'FASTZOMBIE':'images/fastzombie.png',
	'BIGZOMBIE':'images/bigzombie.png',
	'OTHER':'images/other.png'
}

function parseArray(raw) {
	var a = new Array(raw.length);
	for (var i = 0; i < a.length; i++) {
		var line = raw[i][0].split(',');
		a[i] = new Array(line.length)
		for (var j = 0; j < a[i].length; j++) {
			a[i][j] = parseFloat(line[j]);
		}
	}
	return a
	
}

function parseLoc(raw, origin) {
	var s = raw.split(",");
	var ox = 0;
	var oy = 0;
	if (origin !== undefined) {
		ox = origin.x;
		oy = origin.y;
	}
	return {x:parseFloat(s[0])-ox, y:parseFloat(s[1])-oy};
}

function getMap() {
	var rawMap = game.replay.Header.Map;
	var height = rawMap.Height;
	var width = rawMap.Width;
	game.map = {
		width:width,
		height:height,
		name:rawMap.Name,
		origin:parseLoc(rawMap.Origin),
		rubble:parseArray(rawMap.InitialRubble),
		parts:parseArray(rawMap.InitialParts)
	};
}

function rgb(r, g, b) {
	r = Math.min(255,Math.max(0,r*256));
	g = Math.min(255,Math.max(0,g*256));
	b = Math.min(255,Math.max(0,b*256));
	var color = r*256*256 + g*256 + b;
	return color;
}

function drawMap() {
	var margin = 50;
	var width = game.map.width;
	var height = game.map.height; 
	
	var sx = (renderer.width - margin*2) / width;
	var sy = (renderer.height - margin*2) / height;
	var scale = Math.min(sx, sy);
	game.scale = scale;
	var mx = 0;// (renderer.width - width * scale) / 2;
	var my = 0;//(renderer.height - height * scale) / 2;

	var graphics = game.render.map;
	if (game.render.map === undefined) {
		graphics = new PIXI.Graphics();
		game.render.map = graphics;
		board = new PIXI.Container();
		board.addChild(graphics);
		game.render.units = new PIXI.Graphics();
		game.render.units.x=0.5;
		game.render.units.y=0.5;
		board.addChild(game.render.units);
		game.render.effects= new PIXI.Graphics();
		game.render.effects.x=0.5;
		game.render.effects.y=0.5;
		board.addChild(game.render.effects);
		board.x = mx;
		board.y = my;
		board.scale.x = scale;
		board.scale.y = scale;
		stage.addChild(board);

		game.units = {}
		game.effects = {}
		game.effectCount = {}
	}

	// set a fill and line style
	graphics.clear();
	//graphics.beginFill(0xFF3300);
	graphics.lineStyle(1/scale, 0x555500, 1);

	for (var i = 0; i < width; i++) {
		for (var j = 0; j < height; j++) {
			var x = i;
			var y = j;
			var rubble = game.map.rubble[j][i];
			var part = game.map.parts[j][i];
			var color = rgb(rubble / 100, part / 100, 0); 
			graphics.beginFill(color, 0.5);
			graphics.moveTo(x, y);
			graphics.lineTo(x+1, y);
			graphics.lineTo(x+1, y+1);
			graphics.lineTo(x, y+1);
			graphics.lineTo(x, y);
			graphics.endFill();
		}
	}
	graphics.endFill();
}

function teamColor(team, b) {
	if (b === undefined) {
		b = 0;
	}
	var color;
	if (team === "A") {
		color = rgb(b+1,b,b);
	} else if (team === "B") {
		color = rgb(b,b,b+1);
	} else {
		color = rgb(b,b+1,b);
	}
	return color;
}

function createUnitSprite(kind, team) {
	var resource = sprites[kind];
	if (resource === undefined) {
		resource = sprites['OTHER'];
	}
	var sprite = PIXI.Sprite.fromImage(resource);
	var color = teamColor(team);
	sprite.tint = color;
	return sprite;
}

function drawUnit(graphic, x, y, team, kind, sprite) {
	sprite.x = x-0.5;
	sprite.y = y-0.5;
	sprite.width = 1;
	sprite.height = 1;
	graphic.addChild(sprite);
}

function drawAttack(graphic, x, y, x2, y2, t, team) {
	var t1 = Math.min(1,Math.max(0, (t)));
	var t0 = Math.min(1,Math.max(0, t - 0.1));
	var sx = x*(1-t0) + x2*t0;
	var sy = y*(1-t0) + y2*t0;
	var ex = x*(1-t1) + x2*t1;
	var ey = y*(1-t1) + y2*t1;
	var color = teamColor(team, 0.5); 
	graphic.lineStyle(2/game.scale, color, 1);
	graphic.moveTo(sx, sy);
	graphic.lineTo(ex, ey);
	graphic.endFill();
}

function drawUnits(time) {
	game.render.units.clear();
	for (var id in game.units) {
		if (game.units.hasOwnProperty(id)) {
			var robot = game.units[id]
			var t = Math.min(1, game.currentRound - robot.start + time * 2);
			var x = robot.from.x*(1-t) + robot.loc.x * t;
			var y = robot.from.y*(1-t) + robot.loc.y * t;
			drawUnit(game.render.units, x, y, robot.team, robot.kind, robot.sprite);
		}
	}
}

function drawEffects(time) {
	game.render.effects.clear();
	for (var id in game.effects) {
		if (game.effects.hasOwnProperty(id)) {
			var effect = game.effects[id]
			if (game.currentRound - effect.start > effect.duration) {
				delete game.effects[id];
			} else {
				if (effect.type == "attack") {
					var t = (game.currentRound - effect.start + time) / effect.duration;
					drawAttack(game.render.effects, effect.x, effect.y, effect.x2, effect.y2, t, effect.team);
				}
			}
		}
	}
}

function animate() {
	var now = new Date();
	if (game.lastRenderedRound !== game.currentRound) {
		game.lastRenderedRound = game.currentRound;
	}
	var time = (now - game.lastRoundTime) / MS_PER_ROUND;
	if (time < 0 || time >= 1) {
		time = Math.max(0, Math.min(1, time));
	}

	if (game.map !== undefined && game.isMapDrawn === undefined) {
		game.isMapDrawn = true;
		drawMap();
	}

	if (game.units !== undefined) {
		drawUnits(time);
	}
	if (game.effects !== undefined) {
		drawEffects(time);
	}

	if (game.render.bunny !== undefined) {
		game.render.bunny.rotation += 0.1;
	}

	renderer.render(stage);

	game.lastFrameTime = now;
	if (game.Stopped !== true) {
		requestAnimationFrame(animate);
		if (game.lastRoundTime === undefined) {
			game.lastRoundTime = now;
		}
		var roundDelta = now - game.lastRoundTime;
		if (game.isReady === false && roundDelta > MS_PER_ROUND) {
			game.lastRoundTime = now;
			game.requestMore();
		}
	}
}

animate();

//Stream replay
var replayStream = new WebSocket("ws://localhost:8080/replay/stream?id=" + query.id); 
replayStream.onopen = function() {
	replayStream.send("Connection init");
	console.log("Connection Open");
	game.replay = {};
	game.currentRound = 0;
	game.isReady = true;
	game.requestMore = function() {
		isReady = true;
		replayStream.send("")
	}
	game.maxRounds = 5;
}

function parseRound() {
	var signals = game.replay.Round.Signals;
	if (signals !== null && signals !== undefined) {
		for (var i = 0; i < signals.length; i++) {
			var sig = signals[i];
			var type = sig.XMLName.Local;
			if (type === "sig.SpawnSignal") {
				var loc = parseLoc(sig.Loc, game.map.origin);
				var id = sig.RobotId;
				var kind = sig.Type;
				var team = sig.Team;
				var sprite = createUnitSprite(kind, team);
				game.units[id] = {team:team, loc:loc, from:loc, kind:kind, creator:sig.ParentId, delay:sig.Delay, start:game.currentRound, sprite:sprite}
			} else if (type === "sig.MovementSignal") {
				var loc = parseLoc(sig.NewLoc, game.map.origin);
				var id = sig.RobotId;
				var robot = game.units[id];
				robot.from = robot.loc;
				robot.loc = loc;
				robot.delay = sig.Delay;
				robot.start = game.currentRound;
			} else if (type === "sig.IndicatorStringSignal") {
			} else if (type === "sig.BroadcastSignal") {
			} else if (type === "sig.DeathSignal") {
				game.render.units.removeChild(game.units[sig.ObjectId].sprite);
				delete game.units[sig.ObjectId];
			} else if (type === "sig.AttackSignal") {
				var loc = parseLoc(sig.TargetLoc, game.map.origin);
				var id = sig.RobotId;
				var robot = game.units[id];
				var source = robot.loc;
				game.effects[game.effectCount] = {type:"attack", x:source.x, y:source.y, x2:loc.x, y2:loc.y, duration:1, start:game.currentRound, team:robot.team}; 
				game.effectCount++;
			} else if (type === "sig.InfectionSignal") {
			} else if (type === "sig.TeamResourceSignal") {
			} else if (type === "sig.HealthChangeSignal") {
			} else if (type === "sig.BytecodesUsedSignal") {
			} else if (type === "sig.RobotDelaySignal") {
			} else if (type === "sig.ClearRubbleSignal") {
			} else if (type === "sig.RubbleChangeSignal") {
			} else if (type === "sig.PartsChangeSignal") {
			} else {
				console.log(sig.XMLName.Local, sig);
				//game.Stopped = true;
			}
		}
	}
}
   
replayStream.onmessage = function(e) {
	var response = JSON.parse(e.data);
	game.replay[response.MessageType] = response.Data
	if (response.MessageType == "Round") {
		game.currentRound = game.currentRound + 1;
		parseRound();
	}
	game.isReady = false;

	if (game.replay.Header !== undefined && game.map === undefined) {
		getMap();	
	}
};

replayStream.onclose = function() {
	game.Stopped = true;
	console.log("websocket closed")
}
</script>
</html>
